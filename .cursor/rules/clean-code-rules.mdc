---
description:
globs:
alwaysApply: true
---



# üìñ Rules do Projeto

## üîπ 1. Clean Code

1. **Legibilidade acima de tudo**

MUITO IMPORTANTE : N√£o usar coment√°rios no c√≥digo (//), nunca usar... o c√≥digo deve ser auto explicativo

   * Nomeie vari√°veis, fun√ß√µes e classes de forma **clara e descritiva**.
   * Exemplo: `validateCpf()` em vez de `valCpf()`.
2. **Baixa complexidade**

   * Fun√ß√µes devem ter no m√°ximo **20‚Äì30 linhas** e **1 n√≠vel de abstra√ß√£o**.
   * Prefira quebrar em fun√ß√µes menores.
3. **Sem coment√°rios desnecess√°rios**

   * O c√≥digo deve se explicar por si s√≥. Coment√°rios apenas para contexto **de neg√≥cio** ou decis√µes arquiteturais.
4. **Consist√™ncia de estilo**

   * Sempre rodar `pnpm lint` e `pnpm format`.
   * Usar **Prettier** para formata√ß√£o autom√°tica.
5. **Tratamento expl√≠cito de erros**

   * Nunca engolir exce√ß√µes (`try/catch` vazio).
   * Usar **Custom Exceptions** (`DomainError`, `ValidationError`) com mensagens claras.
6. **Evitar duplica√ß√£o (DRY)**

   * Se um c√≥digo √© repetido mais de 2 vezes ‚Üí extrair para fun√ß√£o/util.
7. **Idempot√™ncia e seguran√ßa em API**

   * Endpoints cr√≠ticos (pagamentos) devem validar headers e usar `Idempotency-Key`.

---

## üîπ 2. Clean Architecture

1. **Separa√ß√£o de camadas**

   ```
   interfaces/   ‚Üí controllers, DTOs, pipes, filters
   application/  ‚Üí use-cases, ports, mappers
   domain/       ‚Üí entities, value-objects, regras
   infra/        ‚Üí db (Prisma), providers (Mercado Pago), messaging, observability
   ```

   * Nada de **depend√™ncia circular**.
   * O dom√≠nio **n√£o depende** de infraestrutura.

2. **Use Cases claros**

   * Cada caso de uso deve ter **1 classe/service dedicado**.
   * Exemplo: `CreatePaymentUseCase`.

3. **Interfaces (Ports)**

   * Reposit√≥rios e Providers definidos como **interfaces** no `application/ports`.
   * Implementa√ß√µes ficam em `infra/`.

4. **Domain-Driven Design Light**

   * Entidades (`Payment`) e VOs (`Cpf`) cont√™m **valida√ß√µes de regras**.
   * Estados controlados por **m√°quina de estados** (`PENDING ‚Üí PAID/FAIL`).

5. **Inje√ß√£o de Depend√™ncia**

   * Sempre via **NestJS Providers** (`@Injectable()`, `@Inject`).
   * Nada de new direto no dom√≠nio ‚Üí facilita testes.

6. **Eventos de Dom√≠nio**

   * Altera√ß√µes relevantes (`PaymentStatusChanged`) devem disparar **eventos** ‚Üí public√°veis em RabbitMQ.

---

## üîπ 3. Boas Pr√°ticas

1. **Configura√ß√£o e Secrets**

   * Nunca versionar credenciais.
   * Usar `.env` com schema validado por `zod`/`env-var`.

2. **Banco de Dados**

   * Prisma + migrations versionadas.
   * Sempre usar `@@index` para filtros mais usados (`cpf`, `status`).

3. **Testes**

   * **Unit**: entidades, servi√ßos de dom√≠nio.
   * **Integra√ß√£o**: use-cases + repos.
   * **E2E**: fluxo completo (POST pagamento ‚Üí Webhook ‚Üí GET status).
   * Cobertura m√≠nima: **80%**.

4. **Observabilidade**

   * Logs estruturados (JSON) ‚Üí f√°cil parse.
   * Tracing com OpenTelemetry ativo (mesmo que local no console).

5. **Commits e Git**

   * Seguir **Conventional Commits** (`feat:`, `fix:`, `refactor:`).
   * Branches no formato `feature/payment-create`.

6. **CI/CD Local**

   * Pipeline roda:

     * `pnpm lint`
     * `pnpm type-check`
     * `pnpm test`
     * `pnpm test:e2e`

7. **Docker-first**

   * Todo ambiente sobe com `docker compose up`.
   * Banco, mensageria, stub do Mercado Pago e API na mesma rede local.

---

