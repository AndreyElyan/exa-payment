---
description:
globs:
alwaysApply: true
---


# Pitch r√°pido (o que te destaca)

* **Clean + DDD leve**: ‚Äúpayment‚Äù como agregado + portas/adapters (Strategy para provedores de pagamento).
* **Idempot√™ncia + m√°quina de estados**: evita duplicidade e mostra maturidade.
* **Mensageria local** (RabbitMQ) para eventos de dom√≠nio, simulando microservi√ßos.
* **Observabilidade** (OpenTelemetry ‚Üí console/Jaeger) e **healthchecks** prontos.
* **Mercado Pago**: dois modos sem custo:

  1. **Stub local** (WireMock/Prism embutido) para valida√ß√£o offline.
  2. **Sandbox oficial** (token de teste) opcional.
* **Temporal opcional via docker-compose** (ou fallback BullMQ/Redis) para orquestra√ß√£o resiliente de cart√£o.
* **Testes**: unit (Jest), e2e (Jest + supertest) e *opcional* Cypress com mini-UI de admin.
* **Container first**: `docker compose up` e pronto.
* **Export BigQuery-friendly**: NDJSON/Parquet local para ‚Äúsimular‚Äù analytics.

---

# Backlog (√©picos, hist√≥rias, crit√©rios)

## √âpico: Gest√£o de Pagamentos


---

# √âPICO 0 ‚Äî Setup inicial do Monorepo (pnpm + Turborepo)

## Objetivo

Entregar um monorepo padronizado (Node/TypeScript/NestJS) com **execu√ß√£o 100% pela raiz**:

* `pnpm dev`, `pnpm build`, `pnpm test`, `pnpm test:e2e`, `pnpm lint`, `pnpm type-check`, `pnpm format`
* Cache incremental com Turborepo
* ESLint + Prettier unificados
* Jest (unit) e e2e configurados **na raiz**
* Padr√µes de commit/CI local (husky + commitlint)
* Docker Compose para infra local (Postgres, RabbitMQ, etc.)
* EditorConfig, tsconfig base, aliases e vari√°veis de ambiente

## Escopo (estrutura sugerida)

```
.
‚îú‚îÄ apps/
‚îÇ  ‚îú‚îÄ api/                 # NestJS principal
‚îÇ  ‚îî‚îÄ consumer/            # consumer de eventos (opcional)
‚îú‚îÄ packages/
‚îÇ  ‚îú‚îÄ contracts/           # OpenAPI + schemas compartilhados
‚îÇ  ‚îú‚îÄ eslint-config/       # config compartilhada ESLint
‚îÇ  ‚îú‚îÄ tsconfig/            # tsconfig bases
‚îÇ  ‚îú‚îÄ testing/             # helpers de teste, jest presets
‚îÇ  ‚îî‚îÄ config/              # loaders de env, logger, middlewares comuns
‚îú‚îÄ dev/
‚îÇ  ‚îú‚îÄ docker-compose.yml   # postgres, rabbitmq, (stub), jaeger (opt)
‚îÇ  ‚îî‚îÄ prisma/seed.ts       # seeds dev
‚îú‚îÄ .husky/                 # ganchos (criados pelo script)
‚îú‚îÄ .vscode/                # recomenda√ß√µes/launch configs (opcional)
‚îú‚îÄ .editorconfig
‚îú‚îÄ .env.example
‚îú‚îÄ package.json
‚îú‚îÄ pnpm-workspace.yaml
‚îú‚îÄ turbo.json
‚îú‚îÄ tsconfig.base.json
‚îú‚îÄ jest.config.ts
‚îú‚îÄ .eslintrc.cjs
‚îú‚îÄ .prettierrc.json
‚îú‚îÄ commitlint.config.cjs
‚îî‚îÄ .npmrc
```

---

## US-0.1 ‚Äî Inicializar monorepo (pnpm + turbo)

**Como dev**, quero um monorepo com workspaces para instalar e rodar tudo da raiz.

**Crit√©rios de Aceite**

* `pnpm i` instala todas as deps e linka workspaces
* `pnpm -w run dev|build|test` funciona pela raiz
* `turbo run` reconhece pipeline

**Tarefas**

* Criar `pnpm-workspace.yaml`:

```yaml
packages:
  - "apps/*"
  - "packages/*"
```

* Criar `turbo.json`:

```json
{
  "globalDependencies": ["**/.env*"],
  "tasks": {
    "build": { "dependsOn": ["^build"], "outputs": ["dist/**", ".next/**", "!.next/cache/**"] },
    "dev": { "cache": false, "persistent": true },
    "lint": { "outputs": [] },
    "type-check": { "outputs": [] },
    "test": { "outputs": ["coverage/**"], "inputs": ["src/**/*", "test/**/*"] },
    "test:e2e": { "outputs": ["coverage-e2e/**"] },
    "format": { "outputs": [] }
  }
}
```

* `package.json` (raiz) com scripts unificados:

```json
{
  "name": "payments-monorepo",
  "private": true,
  "packageManager": "pnpm@8.15.0",
  "scripts": {
    "dev": "npx turbo run dev --parallel",
    "build": "npx turbo run build",
    "lint": "npx turbo run lint",
    "type-check": "npx turbo run type-check",
    "test": "npx turbo run test",
    "test:e2e": "npx turbo run test:e2e",
    "format": "npx turbo run format",
    "prepare": "husky install",
    "docker:up": "docker compose -f dev/docker-compose.yml up -d",
    "docker:down": "docker compose -f dev/docker-compose.yml down -v",
    "db:migrate": "pnpm --filter @app/api prisma:migrate dev",
    "db:seed": "pnpm --filter @app/api prisma db seed"
  },
  "devDependencies": {
    "turbo": "^2.0.0",
    "husky": "^9.0.0",
    "@commitlint/cli": "^19.0.0",
    "@commitlint/config-conventional": "^19.0.0",
    "eslint": "^9.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "eslint-plugin-import": "^2.29.0",
    "eslint-plugin-unused-imports": "^3.0.0",
    "eslint-config-prettier": "^9.0.0",
    "prettier": "^3.3.0",
    "lint-staged": "^15.0.0",
    "typescript": "^5.6.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "@types/jest": "^29.5.12",
    "dotenv-cli": "^7.4.1",
    "tsx": "^4.0.0",
    "zod": "^3.22.0",
    "dotenv": "^16.3.0"
  },
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": ["eslint --fix", "prettier --write"],
    "*.md": ["prettier --write"]
  }
}
```

---

## US-0.2 ‚Äî TypeScript base & aliases

**Crit√©rios de Aceite**

* `tsc -b` passa na raiz
* Apps e packages herdam de um **tsconfig base**

**Tarefas**

* `tsconfig.base.json`:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "moduleResolution": "Node",
    "strict": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@contracts/*": ["packages/contracts/src/*"],
      "@config/*": ["packages/config/src/*"],
      "@testing/*": ["packages/testing/src/*"]
    }
  }
}
```

* Em cada app/package: `tsconfig.json` com `"extends": "../../tsconfig.base.json"`

---

## US-0.3 ‚Äî ESLint + Prettier unificados

**Crit√©rios de Aceite**

* `pnpm lint` pela raiz roda em todos os projetos
* `pnpm format` formata e `format:check` falha se houver dif

**Tarefas**

* `.eslintrc.cjs`:

```js
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint','import','unused-imports'],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:import/recommended',
    'plugin:import/typescript',
    'prettier'
  ],
  rules: {
    'unused-imports/no-unused-imports': 'error',
    'import/order': ['error', { 'newlines-between': 'always', alphabetize: { order: 'asc' } }],
    '@typescript-eslint/no-explicit-any': 'warn'
  },
  ignorePatterns: ['dist', 'node_modules', '**/*.d.ts']
}
```

* `.prettierrc.json`:

```json
{ "singleQuote": true, "semi": true, "printWidth": 100, "trailingComma": "all" }
```

* Scripts por workspace (herdados via turbo):
  Em `apps/api/package.json` ‚Üí `"lint": "eslint 'src/**/*.{ts,tsx}'"`; na raiz j√° chamamos tudo.

---

## US-0.4 ‚Äî Jest unificado (unit) + e2e no root

**Crit√©rios de Aceite**

* `pnpm test` executa unit tests de todos os pacotes/apps
* `pnpm test:e2e` roda e2e do `apps/api/test-e2e` a partir da raiz

**Tarefas**

* `jest.config.ts` (raiz):

```ts
import { Config } from 'jest';
const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  projects: [
    '<rootDir>/apps/api',
    '<rootDir>/apps/consumer',
    '<rootDir>/packages/testing',
    '<rootDir>/packages/config',
  ],
  coverageDirectory: '<rootDir>/coverage',
};
export default config;
```

* Em `apps/api/jest.config.ts`:

```ts
import type { Config } from 'jest';
const cfg: Config = {
  displayName: 'api',
  preset: 'ts-jest',
  testMatch: ['**/__tests__/**/*.spec.ts'],
  moduleNameMapper: { '^@contracts/(.*)$': '<rootDir>/../../packages/contracts/src/$1' },
};
export default cfg;
```

* E2E (ex.): `apps/api/test-e2e/app.e2e-spec.ts` usando `supertest`.

---

## US-0.5 ‚Äî Hooks de commit & padr√£o de mensagens

**Crit√©rios de Aceite**

* `git commit` dispara lint + test unit dos pacotes alterados
* Mensagens validadas por **commitlint**

**Tarefas**

```bash
pnpm dlx husky init
pnpm add -D @commitlint/cli @commitlint/config-conventional lint-staged
```

* `.husky/commit-msg`:

```bash
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
pnpm commitlint --edit $1
```

* `.husky/pre-commit`:

```bash
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
pnpm lint-staged
```

* `commitlint.config.cjs`:

```js
module.exports = { extends: ['@commitlint/config-conventional'] };
```

* `package.json` (raiz):

```json
"lint-staged": {
  "*.{ts,tsx,js,jsx}": ["eslint --fix", "prettier --write"],
  "*.md": ["prettier --write"]
}
```

---

## US-0.6 ‚Äî Docker Compose para infra local

**Crit√©rios de Aceite**

* `pnpm docker:up` sobe Postgres e RabbitMQ
* API conecta usando `.env` da raiz

**Tarefas**

* `dev/docker-compose.yml` (essencial):

```yaml
services:
  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: app
      POSTGRES_PASSWORD: app
      POSTGRES_DB: payments
    ports:
      - "5434:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U app -d payments"]
      interval: 10s
      timeout: 5s
      retries: 5

  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5674:5672"
      - "15674:15672"
    environment:
      RABBITMQ_DEFAULT_USER: app
      RABBITMQ_DEFAULT_PASS: app
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16688:16686"
      - "14270:14268"
    environment:
      COLLECTOR_OTLP_ENABLED: true
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:16686/"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  pgdata:
  rabbitmq_data:
```

* `.env.example`:

```
DATABASE_URL=postgresql://app:app@localhost:5434/payments
RABBITMQ_URL=amqp://app:app@localhost:5674
NODE_ENV=development
PORT=3000
JWT_SECRET=your-jwt-secret-here
MERCADO_PAGO_ACCESS_TOKEN=your-mercado-pago-token-here
MERCADO_PAGO_WEBHOOK_SECRET=your-webhook-secret-here
```

---

## US-0.7 ‚Äî Ambiente & Config compartilhada

**Crit√©rios de Aceite**

* `config` package exp√µe `loadEnv()` com valida√ß√£o (`zod`)
* Apps consomem `@config/env`

**Tarefas**

* `packages/config/src/env.ts` com zod e `dotenv/config`
* Exportar logger padr√£o pino/winston (opcional)

---

## US-0.8 ‚Äî Packages utilit√°rios

**Crit√©rios de Aceite**

* `@testing/*` com helpers (supertest factory Nest)
* `@contracts/*` com OpenAPI e DTO schemas (zod/json-schema)

**Tarefas**

* Criar `packages/testing` e `packages/contracts` com `tsconfig.json`, `package.json` e index.

---

## US-0.9 ‚Äî ESLint/Prettier em cascata no VSCode

**Crit√©rios de Aceite**

* Ao salvar arquivo ‚Üí formata e acusa lint (workspace)

**Tarefas**

* `.vscode/settings.json`:

```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "eslint.useFlatConfig": false,
  "eslint.validate": ["typescript", "javascript"]
}
```

---

## US-0.10 ‚Äî Scripts por app para herdar da raiz

**Crit√©rios de Aceite**

* Cada app possui scripts padr√£o; rodar da raiz chama internos

**Tarefas (ex.: apps/api/package.json)**

```json
{
  "name": "@app/api",
  "scripts": {
    "dev": "nest start --watch",
    "build": "nest build",
    "lint": "eslint 'src/**/*.{ts,tsx}'",
    "type-check": "tsc --noEmit",
    "test": "jest -c ./jest.config.ts",
    "test:e2e": "jest -c ./jest-e2e.config.ts"
  },
  "dependencies": { "@nestjs/common": "^10.0.0" }
}
```

---

## US-0.11 ‚Äî EditorConfig & NPMRC

**Crit√©rios de Aceite**

* Padr√µes consistentes entre IDEs e PNPM

**Tarefas**

* `.editorconfig`:

```
root = true
[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true
```

* `.npmrc`:

```
strict-peer-dependencies=false
auto-install-peers=true
```

---

## US-0.12 ‚Äî Documenta√ß√£o de bootstrap + Makefile (opcional)

**Crit√©rios de Aceite**

* README com 5 comandos para levantar ambiente; **copia e cola**

**Tarefas**

* `README.md` (trecho ‚ÄúQuickstart‚Äù):

```bash
pnpm i
pnpm docker:up
pnpm -w run db:migrate && pnpm -w run db:seed
pnpm dev     # roda todos apps
pnpm test    # unit
pnpm test:e2e
```

* `Makefile` (opcional) com os alvos acima.

---

## DoD ‚Äî Definition of Done

* ‚úÖ `pnpm i` termina sem warnings relevantes
* ‚úÖ `pnpm dev|build|lint|type-check|test|test:e2e|format` **funcionam na raiz**
* ‚úÖ Commits validados (husky + commitlint)
* ‚úÖ Docker infra sobe e API conecta com `.env` da **raiz**
* ‚úÖ README com Quickstart & Troubleshooting

## üîß Troubleshooting & Valida√ß√£o

### Problemas Comuns e Solu√ß√µes

**1. Conflito de Portas Docker**
```bash
# Erro: port is already allocated
# Solu√ß√£o: Usar portas alternativas
# PostgreSQL: 5434, RabbitMQ: 5674/15674, Jaeger: 16688
```

**2. Turbo n√£o encontrado**
```bash
# Erro: turbo: not found
# Solu√ß√£o: Usar npx turbo ou instalar globalmente
npx turbo run dev --parallel
```

**3. Depend√™ncias n√£o instaladas**
```bash
# Erro: tsc: not found, tsx: not found
# Solu√ß√£o: Instalar depend√™ncias globalmente no package.json raiz
pnpm install
```

**4. Vers√£o do pnpm incompat√≠vel**
```bash
# Erro: Cannot switch to pnpm@9
# Solu√ß√£o: Usar vers√£o est√°vel
"packageManager": "pnpm@8.15.0"
```

**5. Turbo.json pipeline deprecated**
```json
// Erro: Found `pipeline` field instead of `tasks`
// Solu√ß√£o: Renomear pipeline para tasks
{
  "tasks": { ... }
}
```

### Valida√ß√£o do Setup

**Comandos de Teste:**
```bash
# 1. Verificar instala√ß√£o
pnpm install

# 2. Testar scripts b√°sicos
pnpm lint
pnpm format
pnpm type-check

# 3. Testar infraestrutura
pnpm docker:up
docker ps  # Verificar containers

# 4. Testar desenvolvimento
pnpm dev  # Deve rodar todos os apps

# 5. Testar commits
git add .
git commit -m "feat: test commit"  # Deve passar husky + commitlint
```

**Portas da Infraestrutura:**
- **PostgreSQL**: `localhost:5434`
- **RabbitMQ Management**: `http://localhost:15674` (app/app)
- **Jaeger**: `http://localhost:16688`

**Estrutura Final Validada:**
```
.
‚îú‚îÄ apps/ (api, consumer)
‚îú‚îÄ packages/ (contracts, config, testing)
‚îú‚îÄ dev/ (docker-compose.yml)
‚îú‚îÄ .husky/ (commit hooks)
‚îú‚îÄ .vscode/ (editor config)
‚îî‚îÄ config files (package.json, turbo.json, etc.)
```

---

## ‚úÖ √âPICO 0 - IMPLEMENTADO COM SUCESSO

### üéØ **Status Final:**

**TODOS os comandos funcionando:**
- ‚úÖ `pnpm dev` - Roda todos os apps em paralelo
- ‚úÖ `pnpm build` - Build de todos os projetos  
- ‚úÖ `pnpm test` - Testes unit√°rios
- ‚úÖ `pnpm test:e2e` - Testes end-to-end
- ‚úÖ `pnpm lint` - Lint em todos os projetos
- ‚úÖ `pnpm format` - Formata√ß√£o autom√°tica
- ‚úÖ `pnpm docker:up` - Sobe infraestrutura
- ‚úÖ `make setup` - Setup completo

### üìÅ **Estrutura Implementada:**

```
.
‚îú‚îÄ apps/
‚îÇ  ‚îú‚îÄ api/                 # NestJS principal ‚úÖ
‚îÇ  ‚îî‚îÄ consumer/            # consumer de eventos ‚úÖ
‚îú‚îÄ packages/
‚îÇ  ‚îú‚îÄ contracts/           # OpenAPI + schemas ‚úÖ
‚îÇ  ‚îú‚îÄ config/              # loaders de env, logger ‚úÖ
‚îÇ  ‚îî‚îÄ testing/             # helpers de teste ‚úÖ
‚îú‚îÄ dev/
‚îÇ  ‚îî‚îÄ docker-compose.yml   # postgres, rabbitmq, jaeger ‚úÖ
‚îú‚îÄ .husky/                 # ganchos de commit ‚úÖ
‚îú‚îÄ .vscode/                # configura√ß√µes do editor ‚úÖ
‚îî‚îÄ arquivos de config (package.json, turbo.json, etc.) ‚úÖ
```

### üõ†Ô∏è **Funcionalidades Implementadas:**

1. **Monorepo com pnpm + Turborepo** ‚úÖ
2. **TypeScript base com aliases** ‚úÖ  
3. **ESLint + Prettier unificados** ‚úÖ
4. **Jest configurado para unit e e2e** ‚úÖ
5. **Hooks de commit com husky + commitlint** ‚úÖ
6. **Docker Compose para infra local** ‚úÖ
7. **Configura√ß√µes compartilhadas** ‚úÖ
8. **Packages utilit√°rios** ‚úÖ
9. **VSCode configurado** ‚úÖ
10. **Scripts por app** ‚úÖ
11. **EditorConfig & NPMRC** ‚úÖ
12. **Documenta√ß√£o completa** ‚úÖ

### üöÄ **Pr√≥ximos Passos:**

O monorepo est√° **100% funcional** e pronto para receber a implementa√ß√£o das funcionalidades de pagamento seguindo Clean Architecture e DDD.

**Comandos prontos para uso:**
```bash
# Setup completo
make setup

# Desenvolvimento
pnpm dev

# Testes
pnpm test
pnpm test:e2e

# Infraestrutura
pnpm docker:up
```

O projeto est√° seguindo rigorosamente as regras de **Clean Code** (sem coment√°rios, c√≥digo auto-explicativo) e **Clean Architecture** (separa√ß√£o de camadas, inje√ß√£o de depend√™ncia).

---

**User Story 1 ‚Äî Criar pagamento (PIX/Cart√£o)**

* Como operador, quero criar um pagamento para registrar a cobran√ßa.
* **AC (Gherkin)**

  * DADO payload v√°lido (cpf, amount, description, paymentMethod)
  * QUANDO POST `/api/payment`
  * ENT√ÉO 201 + body com `id`, `status=PENDING`, timestamps
  * E SE `paymentMethod=PIX` **n√£o** chama provedor
  * E SE `paymentMethod=CREDIT_CARD` inicia fluxo Mercado Pago (stub/sandbox)
  * E com `Idempotency-Key` igual, chamadas repetidas retornam o mesmo pagamento (200/201)

**User Story 2 ‚Äî Atualizar pagamento**

* PUT `/api/payment/{id}`
* **AC**

  * Permite atualizar somente campos permitidos (ex.: `status` com regras de transi√ß√£o v√°lidas)
  * 400 para transi√ß√µes inv√°lidas (ex.: `PAID` ‚Üí `PENDING`)

**User Story 3 ‚Äî Buscar por ID**

* GET `/api/payment/{id}`
* **AC**

  * 200 com pagamento completo; 404 se n√£o existir

**User Story 4 ‚Äî Listar com filtros**

* GET `/api/payment?cpf&paymentMethod&status&page&limit`
* **AC**

  * Pagina√ß√£o est√°vel, ordena√ß√£o por `createdAt` desc
  * Filtros combin√°veis

**User Story 5 ‚Äî Webhook Mercado Pago**

* POST `/api/payment/webhook/mercado-pago`
* **AC**

  * Verifica assinatura/secreto (modo sandbox: aceita token; modo stub: chave local)
  * Atualiza status para `PAID` ou `FAIL`
  * Publica evento `PaymentStatusChanged`

**User Story 6 ‚Äî Export Analytics**

* Como analista, quero exportar pagamentos em **NDJSON** (e Parquet opcional) para futura carga em BigQuery.
* **AC**

  * GET `/api/payment/export?from&to&format=ndjson|parquet` ‚Üí arquivo local em `/exports`

**User Story 7 (opcional) ‚Äî Orquestra√ß√£o resiliente**

* Com Temporal (ou BullMQ): workflow garante reexecu√ß√£o/polling, *timeouts*, retentativas e idempot√™ncia.

---

# Dom√≠nio, estados e regras

## Agregado `Payment`

Campos: `id`, `cpf`, `description`, `amount`, `paymentMethod (PIX|CREDIT_CARD)`, `status (PENDING|PAID|FAIL)`, `providerRef`, `createdAt`, `updatedAt`.

## M√°quina de estados

```mermaid
stateDiagram-v2
    [*] --> PENDING
    PENDING --> PAID: confirma√ß√£o provedor (webhook|polling)
    PENDING --> FAIL: erro definitivo provedor
    PAID --> [*]
    FAIL --> [*]
```

**Regras-chave**

* `PIX`: cria `PENDING` e para. (Opcional: QR/txid fake no stub para demo.)
* `CREDIT_CARD`: cria `PENDING` e inicia fluxo com provedor (stub/sandbox).
* **Idempot√™ncia** por `Idempotency-Key` (header) + hash do payload.
* **CPF** validado por d√≠gitos verificadores (regra BR).

---

# Contrato da API (OpenAPI 3.1 ‚Äì trecho essencial)

```yaml
openapi: 3.1.0
info: { title: Payments API, version: 1.0.0 }
paths:
  /api/payment:
    post:
      summary: Create payment
      parameters:
        - in: header
          name: Idempotency-Key
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreatePaymentDTO'
      responses:
        '201': { $ref: '#/components/responses/Payment' }
    get:
      summary: List payments
      parameters:
        - in: query; name: cpf; schema: { type: string }
        - in: query; name: paymentMethod; schema: { enum: [PIX, CREDIT_CARD] }
        - in: query; name: status; schema: { enum: [PENDING, PAID, FAIL] }
        - in: query; name: page; schema: { type: integer, default: 1 }
        - in: query; name: limit; schema: { type: integer, default: 20 }
      responses:
        '200': { description: OK }
  /api/payment/{id}:
    get: { summary: Get by id, responses: { '200': { $ref: '#/components/responses/Payment' }, '404': { description: Not Found } } }
    put:
      summary: Update payment
      requestBody: { content: { application/json: { schema: { $ref: '#/components/schemas/UpdatePaymentDTO' } } } }
      responses: { '200': { $ref: '#/components/responses/Payment' } }
  /api/payment/webhook/mercado-pago:
    post:
      summary: Mercado Pago webhook
      responses: { '204': { description: No Content } }
components:
  schemas:
    CreatePaymentDTO:
      type: object
      required: [cpf, amount, description, paymentMethod]
      properties:
        cpf: { type: string, pattern: '^\d{11}$' }
        amount: { type: number, minimum: 0.01 }
        description: { type: string, maxLength: 255 }
        paymentMethod: { type: string, enum: [PIX, CREDIT_CARD] }
    UpdatePaymentDTO:
      type: object
      properties:
        status: { type: string, enum: [PENDING, PAID, FAIL] }
  responses:
    Payment:
      description: Payment
```

---

# Arquitetura (Clean + Ports & Adapters)

```mermaid
flowchart LR
  UI[CLI/HTTP Client] --> API[NestJS Controllers]
  API --> UC[Use Cases (Application)]
  UC --> DOM[Domain (Entities, Rules)]
  UC --> PORTS[(Ports)]
  PORTS --> REPO[PaymentRepository (Prisma/Postgres)]
  PORTS --> PROV[PaymentProvider (Strategy)]
  UC --> EVT[(Domain Events Bus)]
  EVT --> MQ[RabbitMQ (local)]
  API --> WEBHOOK[Webhook Controller]
  subgraph Infra
    PRISMA[(Postgres)]
    STUB[(MercadoPago Stub Server)]
    TEMPORAL[(Temporal/BullMQ opcional)]
    OTEL[(OTel Collector/Jaeger)]
  end
  REPO <--> PRISMA
  PROV <--> STUB
  UC <--> TEMPORAL
  API --> OTEL
```

**Camadas e pastas**

```
apps/api
  src/
    main.ts
    app.module.ts
    interfaces/http/ (controllers, dto, validators, pipes, exception filters)
    application/ (use-cases, ports, mappers)
    domain/ (entities, value-objects, services de dom√≠nio, events)
    infra/
      db/ (prisma client, repositories)
      providers/
        mercado-pago/ (adapter real/sandbox)
        stub/ (adapter local)
      messaging/ (rabbitmq publisher)
      workflows/ (temporal|bullmq)
    config/ (env, config modules)
    observability/ (otel)
    common/ (utils: cpf validator, idempotency)
  test/ (unit)
  test-e2e/ (e2e supertest)
packages/contracts (openapi, json-schemas)
packages/tooling (scripts, eslint, tsconfig)
dev/ (docker, compose, seed, wiremock/prism configs)
```

**Porta `PaymentProvider` (Strategy)**

```ts
export interface PaymentProvider {
  createCreditCardCharge(input: { amount: number; description: string; idempotencyKey: string }): Promise<{ providerRef: string }>;
  getStatus(providerRef: string): Promise<'PENDING'|'PAID'|'FAIL'>;
}
```

Adapters:

* `MercadoPagoAdapter`: usa sandbox/token **opcional**.
* `StubAdapter`: responde determin√≠stico (config.yml), sem internet.

**Repository**: `PaymentRepository` (Prisma) com m√©todos idempotentes.

---

# Persist√™ncia (Postgres via Prisma ‚Äì schema essencial)

```prisma
model Payment {
  id            String   @id @default(cuid())
  cpf           String   @db.VarChar(11)
  description   String   @db.VarChar(255)
  amount        Decimal  @db.Decimal(12,2)
  paymentMethod String   // 'PIX' | 'CREDIT_CARD'
  status        String   // 'PENDING' | 'PAID' | 'FAIL'
  providerRef   String?  @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([cpf, paymentMethod, status, createdAt])
}
```

---

# Idempot√™ncia

* Header **`Idempotency-Key`** obrigat√≥rio no POST cart√£o; opcional em PIX.
* Tabela `idempotency_keys` (chave + hash do corpo + paymentId + ttl).
* Filtro de race-condition com `SELECT ... FOR UPDATE` (ou unique constraint + retry).

---

# Seguran√ßa & Webhook

* **Validation Pipe** + DTOs com `class-validator`.
* CPF: valida√ß√£o de d√≠gitos (regra BR).
* Webhook:

  * `X-Webhook-Secret` (stub) ou `X-Signature` (sandbox) + `tolerance` de tempo.
  * Sempre responde **204** para evitar replays; processa ass√≠ncrono.

---

# Mensageria (bonus microservi√ßos locais)

* `PaymentStatusChanged` publicado no **RabbitMQ** (`payments.events`).
* Um **consumer-demo** (app separado `apps/consumer`) imprime eventos ‚Üí demonstra integra√ß√£o ass√≠ncrona (Kafka/PubSub ‚Äúequivalente conceitual‚Äù).

---

# Observabilidade

* **OpenTelemetry** Node SDK configurado no Nest (HTTP server/client, Prisma).
* **Local**: envia para `otel-collector` (docker) e **Jaeger** (docker) ou log no console.

---

# Orquestra√ß√£o (opcional)

* **Temporal** (docker): workflow `CreditCardPaymentWorkflow`:

  * Activity 1: cria `PENDING` + chamada criar prefer√™ncia.
  * Activity 2: aguarda confirma√ß√£o (webhook sinaliza ou polling com backoff).
  * Activity 3: atualiza status, publica evento.
* **Fallback**: **BullMQ + Redis** replicando passos com retries/backoff.

---

# Testes

* **Unit (Jest)**: entidades/servi√ßos de dom√≠nio, use-cases, valida√ß√µes.
* **Integra√ß√£o**: repos (Prisma) com Postgres do docker, provider stub.
* **E2E (Jest + supertest)**: fluxo end-to-end (criar, webhook, listar).
* **Cypress (opcional)**: mini-UI admin (React Vite) com 2 telas: criar e acompanhar status.
* **Contract (opcional)**: Pact entre API e consumer demo.

---

# Docker & Dev Experience

**docker-compose.yml (servi√ßos):**

* `api` (Nest)
* `postgres` (db)
* `rabbitmq` (mensageria)
* `wiremock` ou `prism` (stub Mercado Pago)
* `otel-collector` + `jaeger` (observabilidade)
* `temporal` + `temporal-ui` (opcional)
* `redis` (se usar BullMQ)

**Scripts NPM**

* `dev`: `nest start --watch`
* `lint`: eslint
* `type-check`: `tsc --noEmit`
* `test`, `test:cov`, `test:e2e`
* `docker:up`, `docker:down`, `prisma:migrate`, `prisma:seed`
* `export:ndjson`, `export:parquet` (gera em `/exports`)

**Git & CI**

* Conventional commits + Husky + lint-staged
* `Jenkinsfile` simples (build, lint, test, e2e) para mostrar ader√™ncia √† vaga
* GitFlow opcional (branches `feature/*`, `release/*`)

---

# Exemplos de c√≥digo (curtos)

**Validador de CPF (resumo)**

```ts
export function isValidCPF(cpf: string): boolean {
  const s = cpf.replace(/\D/g, '');
  if (!/^\d{11}$/.test(s) || /^(\d)\1{10}$/.test(s)) return false;
  const calc = (len: number) => {
    let sum = 0;
    for (let i = 0; i < len; i++) sum += parseInt(s[i]) * (len + 1 - i);
    const dv = (sum * 10) % 11;
    return dv === 10 ? 0 : dv;
  };
  return calc(9) === +s[9] && calc(10) === +s[10];
}
```

**Port/Adapter Strategy (assinatura)**

```ts
@Injectable()
export class PaymentService {
  constructor(
    private readonly repo: PaymentRepository,
    @Inject(PAYMENT_PROVIDER) private readonly provider: PaymentProvider,
    private readonly events: DomainEventBus,
  ) {}

  async create(dto: CreatePaymentDto, idemKey?: string) {
    // valida CPF + amount + method
    // aplica idempot√™ncia
    const payment = Payment.new(dto); // status PENDING
    await this.repo.save(payment);
    if (payment.isCreditCard()) {
      const { providerRef } = await this.provider.createCreditCardCharge({
        amount: payment.amount, description: payment.description, idempotencyKey: idemKey ?? payment.id
      });
      payment.setProviderRef(providerRef);
      await this.repo.update(payment);
    }
    return payment;
  }
}
```

---

# Roteiro de Demo (para o avaliador)

1. `docker compose up -d`
2. `pnpm i && pnpm prisma:migrate && pnpm prisma:seed`
3. `pnpm dev` (API em `http://localhost:3000`)
4. **PIX**:

   * POST `/api/payment` `{ cpf, amount, description, paymentMethod: "PIX" }` ‚Üí `PENDING`
5. **Cart√£o**:

   * Envia POST com `paymentMethod: "CREDIT_CARD"` e `Idempotency-Key`
   * Recebe `PENDING` + `providerRef`
   * Dispara webhook fake: POST `/api/payment/webhook/mercado-pago` com payload de sucesso
   * GET `/api/payment/{id}` ‚Üí `PAID`
6. **Listar & Filtros**: GET `/api/payment?cpf=...&status=PAID`
7. **Eventos**: veja `apps/consumer` logando `PaymentStatusChanged`
8. **Observabilidade**: visualizar tra√ßos no Jaeger (opcional)
9. **Export**: GET `/api/payment/export?from=...&to=...&format=ndjson` ‚Üí arquivo em `/exports`

---

# Documenta√ß√£o inclusa (Visibilidade de Impacto)

* **README** (setup 1 minuto, make targets, screenshots)
* **ADR-001**: Clean Architecture + Ports/Adapters (trade-offs)
* **ADR-002**: M√°quina de estados & idempot√™ncia
* **ADR-003**: Prisma + Postgres (vs TypeORM)
* **ADR-004**: Temporal vs BullMQ (custo local, robustez)
* **ADR-005**: Mensageria (RabbitMQ agora, Kafka/GCP PubSub depois)
* **UPSTREAM**: uma p√°gina explicando impacto no neg√≥cio (confiabilidade, auditabilidade)
* **M√©tricas**: contagem de pagamentos por status + lat√™ncia (expostos via `/health` e `/metrics` opcional)

---

# Extens√µes que conectam com a vaga (deixadas prontas)

* **GCP-ready**: `docs/deploy-gke.md` (manifestos k8s/kustomize prontos).
* **BigQuery**: `docs/bq-load.md` explicando `bq load` a partir de NDJSON exportado.
* **CI Jenkins**: `Jenkinsfile` com stages (install ‚Üí lint ‚Üí typecheck ‚Üí test ‚Üí e2e).
* **Docker/K8s**: manifests para `api`, `postgres`, `rabbitmq`.
