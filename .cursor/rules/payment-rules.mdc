---
description:
globs:
alwaysApply: true
---


# Pitch rápido (o que te destaca)

* **Clean + DDD leve**: “payment” como agregado + portas/adapters (Strategy para provedores de pagamento).
* **Idempotência + máquina de estados**: evita duplicidade e mostra maturidade.
* **Mensageria local** (RabbitMQ) para eventos de domínio, simulando microserviços.
* **Observabilidade** (OpenTelemetry → console/Jaeger) e **healthchecks** prontos.
* **Mercado Pago**: dois modos sem custo:

  1. **Stub local** (WireMock/Prism embutido) para validação offline.
  2. **Sandbox oficial** (token de teste) opcional.
* **Temporal opcional via docker-compose** (ou fallback BullMQ/Redis) para orquestração resiliente de cartão.
* **Testes**: unit (Jest), e2e (Jest + supertest) e *opcional* Cypress com mini-UI de admin.
* **Container first**: `docker compose up` e pronto.
* **Export BigQuery-friendly**: NDJSON/Parquet local para “simular” analytics.

---

# Backlog (épicos, histórias, critérios)

## Épico: Gestão de Pagamentos


---

# ÉPICO 0 — Setup inicial do Monorepo (pnpm + Turborepo)

## Objetivo

Entregar um monorepo padronizado (Node/TypeScript/NestJS) com **execução 100% pela raiz**:

* `pnpm dev`, `pnpm build`, `pnpm test`, `pnpm test:e2e`, `pnpm lint`, `pnpm type-check`, `pnpm format`
* Cache incremental com Turborepo
* ESLint + Prettier unificados
* Jest (unit) e e2e configurados **na raiz**
* Padrões de commit/CI local (husky + commitlint)
* Docker Compose para infra local (Postgres, RabbitMQ, etc.)
* EditorConfig, tsconfig base, aliases e variáveis de ambiente

## Escopo (estrutura sugerida)

```
.
├─ apps/
│  ├─ api/                 # NestJS principal
│  └─ consumer/            # consumer de eventos (opcional)
├─ packages/
│  ├─ contracts/           # OpenAPI + schemas compartilhados
│  ├─ eslint-config/       # config compartilhada ESLint
│  ├─ tsconfig/            # tsconfig bases
│  ├─ testing/             # helpers de teste, jest presets
│  └─ config/              # loaders de env, logger, middlewares comuns
├─ dev/
│  ├─ docker-compose.yml   # postgres, rabbitmq, (stub), jaeger (opt)
│  └─ prisma/seed.ts       # seeds dev
├─ .husky/                 # ganchos (criados pelo script)
├─ .vscode/                # recomendações/launch configs (opcional)
├─ .editorconfig
├─ .env.example
├─ package.json
├─ pnpm-workspace.yaml
├─ turbo.json
├─ tsconfig.base.json
├─ jest.config.ts
├─ .eslintrc.cjs
├─ .prettierrc.json
├─ commitlint.config.cjs
└─ .npmrc
```

---

## US-0.1 — Inicializar monorepo (pnpm + turbo)

**Como dev**, quero um monorepo com workspaces para instalar e rodar tudo da raiz.

**Critérios de Aceite**

* `pnpm i` instala todas as deps e linka workspaces
* `pnpm -w run dev|build|test` funciona pela raiz
* `turbo run` reconhece pipeline

**Tarefas**

* Criar `pnpm-workspace.yaml`:

```yaml
packages:
  - "apps/*"
  - "packages/*"
```

* Criar `turbo.json`:

```json
{
  "globalDependencies": ["**/.env*"],
  "tasks": {
    "build": { "dependsOn": ["^build"], "outputs": ["dist/**", ".next/**", "!.next/cache/**"] },
    "dev": { "cache": false, "persistent": true },
    "lint": { "outputs": [] },
    "type-check": { "outputs": [] },
    "test": { "outputs": ["coverage/**"], "inputs": ["src/**/*", "test/**/*"] },
    "test:e2e": { "outputs": ["coverage-e2e/**"] },
    "format": { "outputs": [] }
  }
}
```

* `package.json` (raiz) com scripts unificados:

```json
{
  "name": "payments-monorepo",
  "private": true,
  "packageManager": "pnpm@8.15.0",
  "scripts": {
    "dev": "npx turbo run dev --parallel",
    "build": "npx turbo run build",
    "lint": "npx turbo run lint",
    "type-check": "npx turbo run type-check",
    "test": "npx turbo run test",
    "test:e2e": "npx turbo run test:e2e",
    "format": "npx turbo run format",
    "prepare": "husky install",
    "docker:up": "docker compose -f dev/docker-compose.yml up -d",
    "docker:down": "docker compose -f dev/docker-compose.yml down -v",
    "db:migrate": "pnpm --filter @app/api prisma:migrate dev",
    "db:seed": "pnpm --filter @app/api prisma db seed"
  },
  "devDependencies": {
    "turbo": "^2.0.0",
    "husky": "^9.0.0",
    "@commitlint/cli": "^19.0.0",
    "@commitlint/config-conventional": "^19.0.0",
    "eslint": "^9.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "eslint-plugin-import": "^2.29.0",
    "eslint-plugin-unused-imports": "^3.0.0",
    "eslint-config-prettier": "^9.0.0",
    "prettier": "^3.3.0",
    "lint-staged": "^15.0.0",
    "typescript": "^5.6.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "@types/jest": "^29.5.12",
    "dotenv-cli": "^7.4.1",
    "tsx": "^4.0.0",
    "zod": "^3.22.0",
    "dotenv": "^16.3.0"
  },
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": ["eslint --fix", "prettier --write"],
    "*.md": ["prettier --write"]
  }
}
```

---

## US-0.2 — TypeScript base & aliases

**Critérios de Aceite**

* `tsc -b` passa na raiz
* Apps e packages herdam de um **tsconfig base**

**Tarefas**

* `tsconfig.base.json`:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "moduleResolution": "Node",
    "strict": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@contracts/*": ["packages/contracts/src/*"],
      "@config/*": ["packages/config/src/*"],
      "@testing/*": ["packages/testing/src/*"]
    }
  }
}
```

* Em cada app/package: `tsconfig.json` com `"extends": "../../tsconfig.base.json"`

---

## US-0.3 — ESLint + Prettier unificados

**Critérios de Aceite**

* `pnpm lint` pela raiz roda em todos os projetos
* `pnpm format` formata e `format:check` falha se houver dif

**Tarefas**

* `.eslintrc.cjs`:

```js
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint','import','unused-imports'],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:import/recommended',
    'plugin:import/typescript',
    'prettier'
  ],
  rules: {
    'unused-imports/no-unused-imports': 'error',
    'import/order': ['error', { 'newlines-between': 'always', alphabetize: { order: 'asc' } }],
    '@typescript-eslint/no-explicit-any': 'warn'
  },
  ignorePatterns: ['dist', 'node_modules', '**/*.d.ts']
}
```

* `.prettierrc.json`:

```json
{ "singleQuote": true, "semi": true, "printWidth": 100, "trailingComma": "all" }
```

* Scripts por workspace (herdados via turbo):
  Em `apps/api/package.json` → `"lint": "eslint 'src/**/*.{ts,tsx}'"`; na raiz já chamamos tudo.

---

## US-0.4 — Jest unificado (unit) + e2e no root

**Critérios de Aceite**

* `pnpm test` executa unit tests de todos os pacotes/apps
* `pnpm test:e2e` roda e2e do `apps/api/test-e2e` a partir da raiz

**Tarefas**

* `jest.config.ts` (raiz):

```ts
import { Config } from 'jest';
const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  projects: [
    '<rootDir>/apps/api',
    '<rootDir>/apps/consumer',
    '<rootDir>/packages/testing',
    '<rootDir>/packages/config',
  ],
  coverageDirectory: '<rootDir>/coverage',
};
export default config;
```

* Em `apps/api/jest.config.ts`:

```ts
import type { Config } from 'jest';
const cfg: Config = {
  displayName: 'api',
  preset: 'ts-jest',
  testMatch: ['**/__tests__/**/*.spec.ts'],
  moduleNameMapper: { '^@contracts/(.*)$': '<rootDir>/../../packages/contracts/src/$1' },
};
export default cfg;
```

* E2E (ex.): `apps/api/test-e2e/app.e2e-spec.ts` usando `supertest`.

---

## US-0.5 — Hooks de commit & padrão de mensagens

**Critérios de Aceite**

* `git commit` dispara lint + test unit dos pacotes alterados
* Mensagens validadas por **commitlint**

**Tarefas**

```bash
pnpm dlx husky init
pnpm add -D @commitlint/cli @commitlint/config-conventional lint-staged
```

* `.husky/commit-msg`:

```bash
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
pnpm commitlint --edit $1
```

* `.husky/pre-commit`:

```bash
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
pnpm lint-staged
```

* `commitlint.config.cjs`:

```js
module.exports = { extends: ['@commitlint/config-conventional'] };
```

* `package.json` (raiz):

```json
"lint-staged": {
  "*.{ts,tsx,js,jsx}": ["eslint --fix", "prettier --write"],
  "*.md": ["prettier --write"]
}
```

---

## US-0.6 — Docker Compose para infra local

**Critérios de Aceite**

* `pnpm docker:up` sobe Postgres e RabbitMQ
* API conecta usando `.env` da raiz

**Tarefas**

* `dev/docker-compose.yml` (essencial):

```yaml
services:
  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: app
      POSTGRES_PASSWORD: app
      POSTGRES_DB: payments
    ports:
      - "5434:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U app -d payments"]
      interval: 10s
      timeout: 5s
      retries: 5

  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5674:5672"
      - "15674:15672"
    environment:
      RABBITMQ_DEFAULT_USER: app
      RABBITMQ_DEFAULT_PASS: app
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16688:16686"
      - "14270:14268"
    environment:
      COLLECTOR_OTLP_ENABLED: true
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:16686/"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  pgdata:
  rabbitmq_data:
```

* `.env.example`:

```
DATABASE_URL=postgresql://app:app@localhost:5434/payments
RABBITMQ_URL=amqp://app:app@localhost:5674
NODE_ENV=development
PORT=3000
JWT_SECRET=your-jwt-secret-here
MERCADO_PAGO_ACCESS_TOKEN=your-mercado-pago-token-here
MERCADO_PAGO_WEBHOOK_SECRET=your-webhook-secret-here
```

---

## US-0.7 — Ambiente & Config compartilhada

**Critérios de Aceite**

* `config` package expõe `loadEnv()` com validação (`zod`)
* Apps consomem `@config/env`

**Tarefas**

* `packages/config/src/env.ts` com zod e `dotenv/config`
* Exportar logger padrão pino/winston (opcional)

---

## US-0.8 — Packages utilitários

**Critérios de Aceite**

* `@testing/*` com helpers (supertest factory Nest)
* `@contracts/*` com OpenAPI e DTO schemas (zod/json-schema)

**Tarefas**

* Criar `packages/testing` e `packages/contracts` com `tsconfig.json`, `package.json` e index.

---

## US-0.9 — ESLint/Prettier em cascata no VSCode

**Critérios de Aceite**

* Ao salvar arquivo → formata e acusa lint (workspace)

**Tarefas**

* `.vscode/settings.json`:

```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "eslint.useFlatConfig": false,
  "eslint.validate": ["typescript", "javascript"]
}
```

---

## US-0.10 — Scripts por app para herdar da raiz

**Critérios de Aceite**

* Cada app possui scripts padrão; rodar da raiz chama internos

**Tarefas (ex.: apps/api/package.json)**

```json
{
  "name": "@app/api",
  "scripts": {
    "dev": "nest start --watch",
    "build": "nest build",
    "lint": "eslint 'src/**/*.{ts,tsx}'",
    "type-check": "tsc --noEmit",
    "test": "jest -c ./jest.config.ts",
    "test:e2e": "jest -c ./jest-e2e.config.ts"
  },
  "dependencies": { "@nestjs/common": "^10.0.0" }
}
```

---

## US-0.11 — EditorConfig & NPMRC

**Critérios de Aceite**

* Padrões consistentes entre IDEs e PNPM

**Tarefas**

* `.editorconfig`:

```
root = true
[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true
```

* `.npmrc`:

```
strict-peer-dependencies=false
auto-install-peers=true
```

---

## US-0.12 — Documentação de bootstrap + Makefile (opcional)

**Critérios de Aceite**

* README com 5 comandos para levantar ambiente; **copia e cola**

**Tarefas**

* `README.md` (trecho “Quickstart”):

```bash
pnpm i
pnpm docker:up
pnpm -w run db:migrate && pnpm -w run db:seed
pnpm dev     # roda todos apps
pnpm test    # unit
pnpm test:e2e
```

* `Makefile` (opcional) com os alvos acima.

---

## DoD — Definition of Done

* ✅ `pnpm i` termina sem warnings relevantes
* ✅ `pnpm dev|build|lint|type-check|test|test:e2e|format` **funcionam na raiz**
* ✅ Commits validados (husky + commitlint)
* ✅ Docker infra sobe e API conecta com `.env` da **raiz**
* ✅ README com Quickstart & Troubleshooting

## 🔧 Troubleshooting & Validação

### Problemas Comuns e Soluções

**1. Conflito de Portas Docker**
```bash
# Erro: port is already allocated
# Solução: Usar portas alternativas
# PostgreSQL: 5434, RabbitMQ: 5674/15674, Jaeger: 16688
```

**2. Turbo não encontrado**
```bash
# Erro: turbo: not found
# Solução: Usar npx turbo ou instalar globalmente
npx turbo run dev --parallel
```

**3. Dependências não instaladas**
```bash
# Erro: tsc: not found, tsx: not found
# Solução: Instalar dependências globalmente no package.json raiz
pnpm install
```

**4. Versão do pnpm incompatível**
```bash
# Erro: Cannot switch to pnpm@9
# Solução: Usar versão estável
"packageManager": "pnpm@8.15.0"
```

**5. Turbo.json pipeline deprecated**
```json
// Erro: Found `pipeline` field instead of `tasks`
// Solução: Renomear pipeline para tasks
{
  "tasks": { ... }
}
```

### Validação do Setup

**Comandos de Teste:**
```bash
# 1. Verificar instalação
pnpm install

# 2. Testar scripts básicos
pnpm lint
pnpm format
pnpm type-check

# 3. Testar infraestrutura
pnpm docker:up
docker ps  # Verificar containers

# 4. Testar desenvolvimento
pnpm dev  # Deve rodar todos os apps

# 5. Testar commits
git add .
git commit -m "feat: test commit"  # Deve passar husky + commitlint
```

**Portas da Infraestrutura:**
- **PostgreSQL**: `localhost:5434`
- **RabbitMQ Management**: `http://localhost:15674` (app/app)
- **Jaeger**: `http://localhost:16688`

**Estrutura Final Validada:**
```
.
├─ apps/ (api, consumer)
├─ packages/ (contracts, config, testing)
├─ dev/ (docker-compose.yml)
├─ .husky/ (commit hooks)
├─ .vscode/ (editor config)
└─ config files (package.json, turbo.json, etc.)
```

---

## ✅ ÉPICO 0 - IMPLEMENTADO COM SUCESSO

### 🎯 **Status Final:**

**TODOS os comandos funcionando:**
- ✅ `pnpm dev` - Roda todos os apps em paralelo
- ✅ `pnpm build` - Build de todos os projetos  
- ✅ `pnpm test` - Testes unitários
- ✅ `pnpm test:e2e` - Testes end-to-end
- ✅ `pnpm lint` - Lint em todos os projetos
- ✅ `pnpm format` - Formatação automática
- ✅ `pnpm docker:up` - Sobe infraestrutura
- ✅ `make setup` - Setup completo

### 📁 **Estrutura Implementada:**

```
.
├─ apps/
│  ├─ api/                 # NestJS principal ✅
│  └─ consumer/            # consumer de eventos ✅
├─ packages/
│  ├─ contracts/           # OpenAPI + schemas ✅
│  ├─ config/              # loaders de env, logger ✅
│  └─ testing/             # helpers de teste ✅
├─ dev/
│  └─ docker-compose.yml   # postgres, rabbitmq, jaeger ✅
├─ .husky/                 # ganchos de commit ✅
├─ .vscode/                # configurações do editor ✅
└─ arquivos de config (package.json, turbo.json, etc.) ✅
```

### 🛠️ **Funcionalidades Implementadas:**

1. **Monorepo com pnpm + Turborepo** ✅
2. **TypeScript base com aliases** ✅  
3. **ESLint + Prettier unificados** ✅
4. **Jest configurado para unit e e2e** ✅
5. **Hooks de commit com husky + commitlint** ✅
6. **Docker Compose para infra local** ✅
7. **Configurações compartilhadas** ✅
8. **Packages utilitários** ✅
9. **VSCode configurado** ✅
10. **Scripts por app** ✅
11. **EditorConfig & NPMRC** ✅
12. **Documentação completa** ✅

### 🚀 **Próximos Passos:**

O monorepo está **100% funcional** e pronto para receber a implementação das funcionalidades de pagamento seguindo Clean Architecture e DDD.

**Comandos prontos para uso:**
```bash
# Setup completo
make setup

# Desenvolvimento
pnpm dev

# Testes
pnpm test
pnpm test:e2e

# Infraestrutura
pnpm docker:up
```

O projeto está seguindo rigorosamente as regras de **Clean Code** (sem comentários, código auto-explicativo) e **Clean Architecture** (separação de camadas, injeção de dependência).

---

**User Story 1 — Criar pagamento (PIX/Cartão)**

* Como operador, quero criar um pagamento para registrar a cobrança.
* **AC (Gherkin)**

  * DADO payload válido (cpf, amount, description, paymentMethod)
  * QUANDO POST `/api/payment`
  * ENTÃO 201 + body com `id`, `status=PENDING`, timestamps
  * E SE `paymentMethod=PIX` **não** chama provedor
  * E SE `paymentMethod=CREDIT_CARD` inicia fluxo Mercado Pago (stub/sandbox)
  * E com `Idempotency-Key` igual, chamadas repetidas retornam o mesmo pagamento (200/201)

**User Story 2 — Atualizar pagamento**

* PUT `/api/payment/{id}`
* **AC**

  * Permite atualizar somente campos permitidos (ex.: `status` com regras de transição válidas)
  * 400 para transições inválidas (ex.: `PAID` → `PENDING`)

**User Story 3 — Buscar por ID**

* GET `/api/payment/{id}`
* **AC**

  * 200 com pagamento completo; 404 se não existir

**User Story 4 — Listar com filtros**

* GET `/api/payment?cpf&paymentMethod&status&page&limit`
* **AC**

  * Paginação estável, ordenação por `createdAt` desc
  * Filtros combináveis

**User Story 5 — Webhook Mercado Pago**

* POST `/api/payment/webhook/mercado-pago`
* **AC**

  * Verifica assinatura/secreto (modo sandbox: aceita token; modo stub: chave local)
  * Atualiza status para `PAID` ou `FAIL`
  * Publica evento `PaymentStatusChanged`

**User Story 6 — Export Analytics**

* Como analista, quero exportar pagamentos em **NDJSON** (e Parquet opcional) para futura carga em BigQuery.
* **AC**

  * GET `/api/payment/export?from&to&format=ndjson|parquet` → arquivo local em `/exports`

**User Story 7 (opcional) — Orquestração resiliente**

* Com Temporal (ou BullMQ): workflow garante reexecução/polling, *timeouts*, retentativas e idempotência.

---

# Domínio, estados e regras

## Agregado `Payment`

Campos: `id`, `cpf`, `description`, `amount`, `paymentMethod (PIX|CREDIT_CARD)`, `status (PENDING|PAID|FAIL)`, `providerRef`, `createdAt`, `updatedAt`.

## Máquina de estados

```mermaid
stateDiagram-v2
    [*] --> PENDING
    PENDING --> PAID: confirmação provedor (webhook|polling)
    PENDING --> FAIL: erro definitivo provedor
    PAID --> [*]
    FAIL --> [*]
```

**Regras-chave**

* `PIX`: cria `PENDING` e para. (Opcional: QR/txid fake no stub para demo.)
* `CREDIT_CARD`: cria `PENDING` e inicia fluxo com provedor (stub/sandbox).
* **Idempotência** por `Idempotency-Key` (header) + hash do payload.
* **CPF** validado por dígitos verificadores (regra BR).

---

# Contrato da API (OpenAPI 3.1 – trecho essencial)

```yaml
openapi: 3.1.0
info: { title: Payments API, version: 1.0.0 }
paths:
  /api/payment:
    post:
      summary: Create payment
      parameters:
        - in: header
          name: Idempotency-Key
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreatePaymentDTO'
      responses:
        '201': { $ref: '#/components/responses/Payment' }
    get:
      summary: List payments
      parameters:
        - in: query; name: cpf; schema: { type: string }
        - in: query; name: paymentMethod; schema: { enum: [PIX, CREDIT_CARD] }
        - in: query; name: status; schema: { enum: [PENDING, PAID, FAIL] }
        - in: query; name: page; schema: { type: integer, default: 1 }
        - in: query; name: limit; schema: { type: integer, default: 20 }
      responses:
        '200': { description: OK }
  /api/payment/{id}:
    get: { summary: Get by id, responses: { '200': { $ref: '#/components/responses/Payment' }, '404': { description: Not Found } } }
    put:
      summary: Update payment
      requestBody: { content: { application/json: { schema: { $ref: '#/components/schemas/UpdatePaymentDTO' } } } }
      responses: { '200': { $ref: '#/components/responses/Payment' } }
  /api/payment/webhook/mercado-pago:
    post:
      summary: Mercado Pago webhook
      responses: { '204': { description: No Content } }
components:
  schemas:
    CreatePaymentDTO:
      type: object
      required: [cpf, amount, description, paymentMethod]
      properties:
        cpf: { type: string, pattern: '^\d{11}$' }
        amount: { type: number, minimum: 0.01 }
        description: { type: string, maxLength: 255 }
        paymentMethod: { type: string, enum: [PIX, CREDIT_CARD] }
    UpdatePaymentDTO:
      type: object
      properties:
        status: { type: string, enum: [PENDING, PAID, FAIL] }
  responses:
    Payment:
      description: Payment
```

---

# Arquitetura (Clean + Ports & Adapters)

```mermaid
flowchart LR
  UI[CLI/HTTP Client] --> API[NestJS Controllers]
  API --> UC[Use Cases (Application)]
  UC --> DOM[Domain (Entities, Rules)]
  UC --> PORTS[(Ports)]
  PORTS --> REPO[PaymentRepository (Prisma/Postgres)]
  PORTS --> PROV[PaymentProvider (Strategy)]
  UC --> EVT[(Domain Events Bus)]
  EVT --> MQ[RabbitMQ (local)]
  API --> WEBHOOK[Webhook Controller]
  subgraph Infra
    PRISMA[(Postgres)]
    STUB[(MercadoPago Stub Server)]
    TEMPORAL[(Temporal/BullMQ opcional)]
    OTEL[(OTel Collector/Jaeger)]
  end
  REPO <--> PRISMA
  PROV <--> STUB
  UC <--> TEMPORAL
  API --> OTEL
```

**Camadas e pastas**

```
apps/api
  src/
    main.ts
    app.module.ts
    interfaces/http/ (controllers, dto, validators, pipes, exception filters)
    application/ (use-cases, ports, mappers)
    domain/ (entities, value-objects, services de domínio, events)
    infra/
      db/ (prisma client, repositories)
      providers/
        mercado-pago/ (adapter real/sandbox)
        stub/ (adapter local)
      messaging/ (rabbitmq publisher)
      workflows/ (temporal|bullmq)
    config/ (env, config modules)
    observability/ (otel)
    common/ (utils: cpf validator, idempotency)
  test/ (unit)
  test-e2e/ (e2e supertest)
packages/contracts (openapi, json-schemas)
packages/tooling (scripts, eslint, tsconfig)
dev/ (docker, compose, seed, wiremock/prism configs)
```

**Porta `PaymentProvider` (Strategy)**

```ts
export interface PaymentProvider {
  createCreditCardCharge(input: { amount: number; description: string; idempotencyKey: string }): Promise<{ providerRef: string }>;
  getStatus(providerRef: string): Promise<'PENDING'|'PAID'|'FAIL'>;
}
```

Adapters:

* `MercadoPagoAdapter`: usa sandbox/token **opcional**.
* `StubAdapter`: responde determinístico (config.yml), sem internet.

**Repository**: `PaymentRepository` (Prisma) com métodos idempotentes.

---

# Persistência (Postgres via Prisma – schema essencial)

```prisma
model Payment {
  id            String   @id @default(cuid())
  cpf           String   @db.VarChar(11)
  description   String   @db.VarChar(255)
  amount        Decimal  @db.Decimal(12,2)
  paymentMethod String   // 'PIX' | 'CREDIT_CARD'
  status        String   // 'PENDING' | 'PAID' | 'FAIL'
  providerRef   String?  @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([cpf, paymentMethod, status, createdAt])
}
```

---

# Idempotência

* Header **`Idempotency-Key`** obrigatório no POST cartão; opcional em PIX.
* Tabela `idempotency_keys` (chave + hash do corpo + paymentId + ttl).
* Filtro de race-condition com `SELECT ... FOR UPDATE` (ou unique constraint + retry).

---

# Segurança & Webhook

* **Validation Pipe** + DTOs com `class-validator`.
* CPF: validação de dígitos (regra BR).
* Webhook:

  * `X-Webhook-Secret` (stub) ou `X-Signature` (sandbox) + `tolerance` de tempo.
  * Sempre responde **204** para evitar replays; processa assíncrono.

---

# Mensageria (bonus microserviços locais)

* `PaymentStatusChanged` publicado no **RabbitMQ** (`payments.events`).
* Um **consumer-demo** (app separado `apps/consumer`) imprime eventos → demonstra integração assíncrona (Kafka/PubSub “equivalente conceitual”).

---

# Observabilidade

* **OpenTelemetry** Node SDK configurado no Nest (HTTP server/client, Prisma).
* **Local**: envia para `otel-collector` (docker) e **Jaeger** (docker) ou log no console.

---

# Orquestração (opcional)

* **Temporal** (docker): workflow `CreditCardPaymentWorkflow`:

  * Activity 1: cria `PENDING` + chamada criar preferência.
  * Activity 2: aguarda confirmação (webhook sinaliza ou polling com backoff).
  * Activity 3: atualiza status, publica evento.
* **Fallback**: **BullMQ + Redis** replicando passos com retries/backoff.

---

# Testes

* **Unit (Jest)**: entidades/serviços de domínio, use-cases, validações.
* **Integração**: repos (Prisma) com Postgres do docker, provider stub.
* **E2E (Jest + supertest)**: fluxo end-to-end (criar, webhook, listar).
* **Cypress (opcional)**: mini-UI admin (React Vite) com 2 telas: criar e acompanhar status.
* **Contract (opcional)**: Pact entre API e consumer demo.

---

# Docker & Dev Experience

**docker-compose.yml (serviços):**

* `api` (Nest)
* `postgres` (db)
* `rabbitmq` (mensageria)
* `wiremock` ou `prism` (stub Mercado Pago)
* `otel-collector` + `jaeger` (observabilidade)
* `temporal` + `temporal-ui` (opcional)
* `redis` (se usar BullMQ)

**Scripts NPM**

* `dev`: `nest start --watch`
* `lint`: eslint
* `type-check`: `tsc --noEmit`
* `test`, `test:cov`, `test:e2e`
* `docker:up`, `docker:down`, `prisma:migrate`, `prisma:seed`
* `export:ndjson`, `export:parquet` (gera em `/exports`)

**Git & CI**

* Conventional commits + Husky + lint-staged
* `Jenkinsfile` simples (build, lint, test, e2e) para mostrar aderência à vaga
* GitFlow opcional (branches `feature/*`, `release/*`)

---

# Exemplos de código (curtos)

**Validador de CPF (resumo)**

```ts
export function isValidCPF(cpf: string): boolean {
  const s = cpf.replace(/\D/g, '');
  if (!/^\d{11}$/.test(s) || /^(\d)\1{10}$/.test(s)) return false;
  const calc = (len: number) => {
    let sum = 0;
    for (let i = 0; i < len; i++) sum += parseInt(s[i]) * (len + 1 - i);
    const dv = (sum * 10) % 11;
    return dv === 10 ? 0 : dv;
  };
  return calc(9) === +s[9] && calc(10) === +s[10];
}
```

**Port/Adapter Strategy (assinatura)**

```ts
@Injectable()
export class PaymentService {
  constructor(
    private readonly repo: PaymentRepository,
    @Inject(PAYMENT_PROVIDER) private readonly provider: PaymentProvider,
    private readonly events: DomainEventBus,
  ) {}

  async create(dto: CreatePaymentDto, idemKey?: string) {
    // valida CPF + amount + method
    // aplica idempotência
    const payment = Payment.new(dto); // status PENDING
    await this.repo.save(payment);
    if (payment.isCreditCard()) {
      const { providerRef } = await this.provider.createCreditCardCharge({
        amount: payment.amount, description: payment.description, idempotencyKey: idemKey ?? payment.id
      });
      payment.setProviderRef(providerRef);
      await this.repo.update(payment);
    }
    return payment;
  }
}
```

---

# Roteiro de Demo (para o avaliador)

1. `docker compose up -d`
2. `pnpm i && pnpm prisma:migrate && pnpm prisma:seed`
3. `pnpm dev` (API em `http://localhost:3000`)
4. **PIX**:

   * POST `/api/payment` `{ cpf, amount, description, paymentMethod: "PIX" }` → `PENDING`
5. **Cartão**:

   * Envia POST com `paymentMethod: "CREDIT_CARD"` e `Idempotency-Key`
   * Recebe `PENDING` + `providerRef`
   * Dispara webhook fake: POST `/api/payment/webhook/mercado-pago` com payload de sucesso
   * GET `/api/payment/{id}` → `PAID`
6. **Listar & Filtros**: GET `/api/payment?cpf=...&status=PAID`
7. **Eventos**: veja `apps/consumer` logando `PaymentStatusChanged`
8. **Observabilidade**: visualizar traços no Jaeger (opcional)
9. **Export**: GET `/api/payment/export?from=...&to=...&format=ndjson` → arquivo em `/exports`

---

# Documentação inclusa (Visibilidade de Impacto)

* **README** (setup 1 minuto, make targets, screenshots)
* **ADR-001**: Clean Architecture + Ports/Adapters (trade-offs)
* **ADR-002**: Máquina de estados & idempotência
* **ADR-003**: Prisma + Postgres (vs TypeORM)
* **ADR-004**: Temporal vs BullMQ (custo local, robustez)
* **ADR-005**: Mensageria (RabbitMQ agora, Kafka/GCP PubSub depois)
* **UPSTREAM**: uma página explicando impacto no negócio (confiabilidade, auditabilidade)
* **Métricas**: contagem de pagamentos por status + latência (expostos via `/health` e `/metrics` opcional)

---

# Extensões que conectam com a vaga (deixadas prontas)

* **GCP-ready**: `docs/deploy-gke.md` (manifestos k8s/kustomize prontos).
* **BigQuery**: `docs/bq-load.md` explicando `bq load` a partir de NDJSON exportado.
* **CI Jenkins**: `Jenkinsfile` com stages (install → lint → typecheck → test → e2e).
* **Docker/K8s**: manifests para `api`, `postgres`, `rabbitmq`.
